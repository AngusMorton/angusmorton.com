{"data":{"logo":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABFUlEQVQY023PvUrDUBTA8ZuCtoMoOLQ4dWhN14x2kEKXFkGoohQ/QBexOHRycAidKkgHHRq69APRoTjFJYODIA6+gSBYfYMmfYLE/5VT6NALP845NyeHc9UoCHZRQvonCLKKE4ZhAXYURTsYoE9dIy5iCzfUJnEdV+RF4iu6ikFH2EPxazzOcJmg4Rnn5C8ysIEOHqTe5/sT3qXOwYOtRr5/wLAqzpCTDXu4p2ETtyjgGJ/cX+se8jeU9fa4RBt5vWENpjzdkoGPcGg4RQsbOMEFmnBRRwVDHEK/yFXfvr/CoPjvZLKcdByDyzWGeajigzorGy0oOeRJiUtITe/pX1XzDk3buIMltSFR/zTtic3060X+8z8PsEUt8G3LVQAAAABJRU5ErkJggg==","width":400,"height":128,"src":"/static/2b5eaa0de166a8b5faebad4955c2200c/51380/ghost-logo.png","srcSet":"/static/2b5eaa0de166a8b5faebad4955c2200c/51380/ghost-logo.png 1x"}}},"markdownRemark":{"html":"<p><a href=\"https://github.com/google/auto\">AutoValue</a> is a tool that lets you remove a lot of the boilerplate associated with writing value types in Java. It does this by using an annotation processor to generate a well-behaved, immutable implementation of an abstract class.</p>\n<p>So, given the abstract class <code class=\"language-text\">Foo</code>, AutoValue will then generate the implementation of the class called <code class=\"language-text\">AutoValue_Foo</code>. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@AutoValue abstract class Foo {\n  public abstract String bar();\n\n  public static Foo create() {\n    return new AutoValue_Foo();\n  } \n}\n\nfinal class AutoValue_Foo extends Foo {\n  AutoValue_Foo() {...}\n  public String bar() {...}\n  @Override public String toString() {...}\n  @Override public boolean equals(Object o) {...}\n  @Override public int hashcode() {...}\n}</code></pre></div>\n<p>So there are some immediately obvious advantages to using AutoValue;</p>\n<ul>\n<li>No runtime cost (since it’s all compile time code generation).</li>\n<li>The generated class is immutable.</li>\n<li>No boilerplate equals()/hashcode()/toString() method implementations.</li>\n</ul>\n<p>However, AutoValue alone is insufficient for Android development because:</p>\n<ul>\n<li>AutoValue_Foo can’t be Parcelable.</li>\n<li>AutoValue_Foo can’t be deserialized automatically by Moshi/Gson (because the class is immutable).</li>\n</ul>\n<h3>Enter AutoValue Extensions</h3>\n<p>AutoValue 1.2 added an Extensibility API that allows you to add custom behavior, like Parcelable, to an AutoValue class.</p>\n<h5>Parcelable AutoValue Extension</h5>\n<p>First we define our AutoValue class <code class=\"language-text\">Foo</code>. Note that our class <code class=\"language-text\">Foo</code> implements <code class=\"language-text\">Parcelable</code>. This tells the Parcelable Extension that it is applicable to this class and it should participate in code generation. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@AutoValue abstract class Foo implements Parcelable {\n  public abstract String bar();\n}</code></pre></div>\n<p>The AutoValue annotation processor will generate a subclass called <code class=\"language-text\">$AutoValue_Foo</code>, which contains all of the normal AutoValue code. Note that it is designated as <code class=\"language-text\">abstract</code> because the Parcelable Extension still needs to fulfill the <code class=\"language-text\">Parcelable</code> interface.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">abstract class $AutoValue_Foo extends Foo {\n  $AutoValue_Foo() {...}\n  public String bar() {...}\n  @Override public String toString() {...}\n  @Override public boolean equals(Object o) {...}\n  @Override public int hashcode() {...}\n}</code></pre></div>\n<p>The ParcelableExtension will then generate <code class=\"language-text\">AutoValue_Foo</code> that extends <code class=\"language-text\">$AutoValue_Foo</code>. This lets the Parcelable Extension implement the Parcelable interface properly.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">final class AutoValue_Foo extends $AutoValue_Foo {\n  @Override public int describeContents() {...}\n  @Override public void writeToParcel(Parcel out, int flags) {...}\n  public static final Parcelable.Creator&lt;AutoValue_Foo&gt; CREATOR = ...\n}</code></pre></div>\n<p>So the full class hierarchy looks like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    Foo\n     ^\n$AutoValue_Foo\n     ^\n AutoValue_Foo</code></pre></div>\n<p>Also note that the final generated class is <em>always</em> called <code class=\"language-text\">AutoValue_Foo</code>, which means that nothing in the consuming code needs to change!</p>\n<h3>TL;DR</h3>\n<p>AutoValue 1.3 has extensions, they are a powerful way to reduce the boilerplate code associated with value types. Use them!</p>\n<hr>\n<h3>See</h3>\n<ul>\n<li><a href=\"https://github.com/google/auto/issues/202\">Extensibility API Issue</a></li>\n<li><a href=\"https://github.com/google/auto/pull/237\">Extensibility API Pull Request</a></li>\n<li><a href=\"https://github.com/rharter/auto-value-moshi\">AutoValue Moshi Extension</a></li>\n<li><a href=\"https://github.com/rharter/auto-value-parcel\">AutoValue Parcelable Extension</a></li>\n<li><a href=\"https://github.com/google/auto/blob/master/value/src/main/java/com/google/auto/value/extension/AutoValueExtension.java\">Source code: AutoValueExtension.java</a></li>\n</ul>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/google/auto"},"children":[{"type":"text","value":"AutoValue"}]},{"type":"text","value":" is a tool that lets you remove a lot of the boilerplate associated with writing value types in Java. It does this by using an annotation processor to generate a well-behaved, immutable implementation of an abstract class."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So, given the abstract class "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Foo"}]},{"type":"text","value":", AutoValue will then generate the implementation of the class called "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"AutoValue_Foo"}]},{"type":"text","value":". "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"@AutoValue abstract class Foo {\n  public abstract String bar();\n\n  public static Foo create() {\n    return new AutoValue_Foo();\n  } \n}\n\nfinal class AutoValue_Foo extends Foo {\n  AutoValue_Foo() {...}\n  public String bar() {...}\n  @Override public String toString() {...}\n  @Override public boolean equals(Object o) {...}\n  @Override public int hashcode() {...}\n}"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So there are some immediately obvious advantages to using AutoValue;"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"No runtime cost (since it’s all compile time code generation)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"The generated class is immutable."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"No boilerplate equals()/hashcode()/toString() method implementations."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"However, AutoValue alone is insufficient for Android development because:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"AutoValue_Foo can’t be Parcelable."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"AutoValue_Foo can’t be deserialized automatically by Moshi/Gson (because the class is immutable)."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Enter AutoValue Extensions"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"AutoValue 1.2 added an Extensibility API that allows you to add custom behavior, like Parcelable, to an AutoValue class."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{},"children":[{"type":"text","value":"Parcelable AutoValue Extension"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"First we define our AutoValue class "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Foo"}]},{"type":"text","value":". Note that our class "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Foo"}]},{"type":"text","value":" implements "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Parcelable"}]},{"type":"text","value":". This tells the Parcelable Extension that it is applicable to this class and it should participate in code generation. "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"@AutoValue abstract class Foo implements Parcelable {\n  public abstract String bar();\n}"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The AutoValue annotation processor will generate a subclass called "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"$AutoValue_Foo"}]},{"type":"text","value":", which contains all of the normal AutoValue code. Note that it is designated as "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"abstract"}]},{"type":"text","value":" because the Parcelable Extension still needs to fulfill the "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Parcelable"}]},{"type":"text","value":" interface."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"abstract class $AutoValue_Foo extends Foo {\n  $AutoValue_Foo() {...}\n  public String bar() {...}\n  @Override public String toString() {...}\n  @Override public boolean equals(Object o) {...}\n  @Override public int hashcode() {...}\n}"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The ParcelableExtension will then generate "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"AutoValue_Foo"}]},{"type":"text","value":" that extends "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"$AutoValue_Foo"}]},{"type":"text","value":". This lets the Parcelable Extension implement the Parcelable interface properly."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"final class AutoValue_Foo extends $AutoValue_Foo {\n  @Override public int describeContents() {...}\n  @Override public void writeToParcel(Parcel out, int flags) {...}\n  public static final Parcelable.Creator<AutoValue_Foo> CREATOR = ...\n}"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So the full class hierarchy looks like:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"    Foo\n     ^\n$AutoValue_Foo\n     ^\n AutoValue_Foo"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Also note that the final generated class is "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"always"}]},{"type":"text","value":" called "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"AutoValue_Foo"}]},{"type":"text","value":", which means that nothing in the consuming code needs to change!"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"TL;DR"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"AutoValue 1.3 has extensions, they are a powerful way to reduce the boilerplate code associated with value types. Use them!"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"See"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/google/auto/issues/202"},"children":[{"type":"text","value":"Extensibility API Issue"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/google/auto/pull/237"},"children":[{"type":"text","value":"Extensibility API Pull Request"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/rharter/auto-value-moshi"},"children":[{"type":"text","value":"AutoValue Moshi Extension"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/rharter/auto-value-parcel"},"children":[{"type":"text","value":"AutoValue Parcelable Extension"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/google/auto/blob/master/value/src/main/java/com/google/auto/value/extension/AutoValueExtension.java"},"children":[{"type":"text","value":"Source code: AutoValueExtension.java"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"excerpt":"AutoValue  is a tool that lets you remove a lot of the boilerplate associated with writing value types in Java. It does this by using an…","timeToRead":2,"frontmatter":{"title":"Autovalue Extensions","userDate":"6 May 2018","date":"2018-05-06T23:46:37.121Z","tags":["android"],"image":null,"author":{"id":"Angus","bio":"The professional publishing platform","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAABMUlEQVQ4y2MwsXf5T03MMGogGBvbOYNpUwdXOIbJwdgwNQQNhCk0snX6r2thC8Y6QGxg7QCWA/FBcrgMxepCkAZrV6//EYmpYBydkvHfMzjiv5mj2//whJT/Nm7ecEMJGgjykp6V/f+AqLj/O/Ye+L8diA8dO/m/pbv/v72n3/+tu/f9D45N/K9naYcSFESFoRXQlSCX2rh7g/kgr1u5epIWhiAMCi/3wLD/fVNn/u+fNgtMT5g+6//kmXOB/Jn/PYLCwWrINnDijDlAPBvKJ8NAZC+DIgCkGYRBbJAYSV5GjpTte/b/PwiMkLj0nP8xqVn/Dxw9AY6kwOh40iIFlmzCgUkmKjnjvx0wdu08fMFskJi1mxfxyQY9YetAEzJyQic5YaNnPeTgIDnrjZaHJGMACtTMXoVAJ6sAAAAASUVORK5CYII=","width":400,"height":400,"src":"/static/5f2c129e42248a92c87b13b4293950cf/fba88/ghost.png","srcSet":"/static/5f2c129e42248a92c87b13b4293950cf/fba88/ghost.png 1x"}}]}}}},"relatedPosts":{"totalCount":3,"edges":[{"node":{"id":"6facbbe0-0547-5610-8527-9afc26a26877","timeToRead":2,"excerpt":"AutoValue  is a tool that lets you remove a lot of the boilerplate associated with writing value types in Java. It does this by using an…","frontmatter":{"title":"Autovalue Extensions"},"fields":{"slug":"/autovalue-extensions/"}}},{"node":{"id":"972ce869-df1a-5e26-af0f-b0506a8034d8","timeToRead":1,"excerpt":" is a  beta  feature in  RxJava  that represents a single value, rather than a stream of values that an   represents. This is useful in…","frontmatter":{"title":"rx.Single"},"fields":{"slug":"/rx-single/"}}},{"node":{"id":"7d02b18d-1972-5b9a-a476-524bba0863bb","timeToRead":1,"excerpt":"Android has a relatively unpredictable habit of killing any   that is not immediately visible to the user to reclaim memory. Because of this…","frontmatter":{"title":"Don't keep activities"},"fields":{"slug":"/dont-keep-activities/"}}}]}},"pageContext":{"slug":"/autovalue-extensions/","prev":null,"next":{"excerpt":" is a  beta  feature in  RxJava  that represents a single value, rather than a stream of values that an   represents. This is useful in…","timeToRead":1,"frontmatter":{"title":"rx.Single","tags":["android"],"date":"2018-05-06T23:46:37.121Z","draft":false,"image":null,"author":{"id":"Angus","bio":"The professional publishing platform","avatar":{"children":[{"fixed":{"src":"/static/5f2c129e42248a92c87b13b4293950cf/fba88/ghost.png"}}]}}},"fields":{"layout":"post","slug":"/rx-single/"}},"primaryTag":"android"}}