<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Angus Morton]]></title><description><![CDATA[Android Development]]></description><link>https://angusmorton.github.io/angusmorton.com</link><generator>RSS for Node</generator><lastBuildDate>Sat, 02 Feb 2019 03:31:43 GMT</lastBuildDate><item><title><![CDATA[rx.Single]]></title><description><![CDATA[ is a  beta  feature in  RxJava  that represents a single value, rather than a stream of values that an   represents. This is useful in…]]></description><link>https://angusmorton.github.io/angusmorton.com/rx-single/</link><guid isPermaLink="false">https://angusmorton.github.io/angusmorton.com/rx-single/</guid><pubDate>Sun, 06 May 2018 23:46:37 GMT</pubDate><content:encoded>&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;rx.Single&lt;/code&gt; is a &lt;strong&gt;beta&lt;/strong&gt; feature in &lt;a href=&quot;https://github.com/ReactiveX/RxJava&quot;&gt;RxJava&lt;/a&gt; that represents a single value, rather than a stream of values that an &lt;code class=&quot;language-text&quot;&gt;rx.Observable&lt;/code&gt; represents. This is useful in simplifying the mental model required for consumers of your API (e.g. a Retrofit service).&lt;/p&gt;
&lt;h6&gt;rx.Observable&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;Respond with an error.&lt;/li&gt;
&lt;li&gt;Never respond.&lt;/li&gt;
&lt;li&gt;Respond successfully with no data and end.&lt;/li&gt;
&lt;li&gt;Respond successfully with a single value and end.&lt;/li&gt;
&lt;li&gt;Respond successfully with multiple values and end.&lt;/li&gt;
&lt;li&gt;Respond successfully with one or more values and don’t end.&lt;/li&gt;
&lt;/ul&gt;
&lt;h6&gt;rx.Single&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;Respond with an error.&lt;/li&gt;
&lt;li&gt;Never respond.&lt;/li&gt;
&lt;li&gt;Respond successfully with a single value.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;p&gt;Consider a public API that retrieves a user’s profile from a network API.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Observable&amp;lt;Profile&amp;gt; getProfile();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The behavior of &lt;code class=&quot;language-text&quot;&gt;getProfile()&lt;/code&gt; is not immediately obvious - can &lt;code class=&quot;language-text&quot;&gt;getProfile()&lt;/code&gt; emit multiple values? when does it end? Maybe it emits a new &lt;code class=&quot;language-text&quot;&gt;Profile&lt;/code&gt; when it gets updated?&lt;/p&gt;
&lt;p&gt;What if we use &lt;code class=&quot;language-text&quot;&gt;rx.Single&lt;/code&gt; instead?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Single&amp;lt;Profile&amp;gt; getProfile();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now the behavior of &lt;code class=&quot;language-text&quot;&gt;getProfile()&lt;/code&gt; explicit - the consumers only need to consider a single value, and that behavior is enforced by the Java type system.&lt;/p&gt;
&lt;h3&gt;TL;DR&lt;/h3&gt;
&lt;p&gt;Consider using &lt;code class=&quot;language-text&quot;&gt;rx.Single&lt;/code&gt; when an API/Service layer should only emit one item.&lt;/p&gt;
&lt;h3&gt;See&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://reactivex.io/documentation/single.html&quot;&gt;ReactiveX Specification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxJava/issues/1594&quot;&gt;RxJava Github Issue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/square/retrofit/issues/969&quot;&gt;Retrofit Support Issue&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Don't keep activities]]></title><description><![CDATA[Android has a relatively unpredictable habit of killing any   that is not immediately visible to the user to reclaim memory. Because of this…]]></description><link>https://angusmorton.github.io/angusmorton.com/dont-keep-activities/</link><guid isPermaLink="false">https://angusmorton.github.io/angusmorton.com/dont-keep-activities/</guid><pubDate>Sun, 06 May 2018 23:46:37 GMT</pubDate><content:encoded>&lt;p&gt;Android has a relatively unpredictable habit of killing any &lt;code class=&quot;language-text&quot;&gt;Activity&lt;/code&gt; that is not immediately visible to the user to reclaim memory. Because of this we need a way to test how our app behaves when our Activities are killed. ‘Don’t keep activities’ forces Android to kill background activities (as though it were in a low memory environment).
From the &lt;a href=&quot;http://developer.android.com/tools/debugging/debugging-devtools.html&quot;&gt;Android Developer Documentation&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tells the system to destroy an activity as soon as it is stopped (as if Android had to reclaim memory) This is very useful for testing the &lt;code class=&quot;language-text&quot;&gt;onSaveInstanceState(Bundle)&lt;/code&gt; / &lt;code class=&quot;language-text&quot;&gt;onCreate(android.os.Bundle)&lt;/code&gt; code path, which would otherwise be difficult to force. Choosing this option will probably reveal a number of problems in your application due to not saving state. For more information about saving an activity’s state, see the Activities document.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Don’t keep activities is in the &lt;strong&gt;Developer options&lt;/strong&gt; settings of your device.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Consider enabling this to test that your app saves state properly.&lt;/em&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Autovalue Extensions]]></title><description><![CDATA[AutoValue  is a tool that lets you remove a lot of the boilerplate associated with writing value types in Java. It does this by using an…]]></description><link>https://angusmorton.github.io/angusmorton.com/autovalue-extensions/</link><guid isPermaLink="false">https://angusmorton.github.io/angusmorton.com/autovalue-extensions/</guid><pubDate>Sun, 06 May 2018 23:46:37 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://github.com/google/auto&quot;&gt;AutoValue&lt;/a&gt; is a tool that lets you remove a lot of the boilerplate associated with writing value types in Java. It does this by using an annotation processor to generate a well-behaved, immutable implementation of an abstract class.&lt;/p&gt;
&lt;p&gt;So, given the abstract class &lt;code class=&quot;language-text&quot;&gt;Foo&lt;/code&gt;, AutoValue will then generate the implementation of the class called &lt;code class=&quot;language-text&quot;&gt;AutoValue_Foo&lt;/code&gt;. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;@AutoValue abstract class Foo {
  public abstract String bar();

  public static Foo create() {
    return new AutoValue_Foo();
  } 
}

final class AutoValue_Foo extends Foo {
  AutoValue_Foo() {...}
  public String bar() {...}
  @Override public String toString() {...}
  @Override public boolean equals(Object o) {...}
  @Override public int hashcode() {...}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So there are some immediately obvious advantages to using AutoValue;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No runtime cost (since it’s all compile time code generation).&lt;/li&gt;
&lt;li&gt;The generated class is immutable.&lt;/li&gt;
&lt;li&gt;No boilerplate equals()/hashcode()/toString() method implementations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, AutoValue alone is insufficient for Android development because:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AutoValue_Foo can’t be Parcelable.&lt;/li&gt;
&lt;li&gt;AutoValue_Foo can’t be deserialized automatically by Moshi/Gson (because the class is immutable).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Enter AutoValue Extensions&lt;/h3&gt;
&lt;p&gt;AutoValue 1.2 added an Extensibility API that allows you to add custom behavior, like Parcelable, to an AutoValue class.&lt;/p&gt;
&lt;h5&gt;Parcelable AutoValue Extension&lt;/h5&gt;
&lt;p&gt;First we define our AutoValue class &lt;code class=&quot;language-text&quot;&gt;Foo&lt;/code&gt;. Note that our class &lt;code class=&quot;language-text&quot;&gt;Foo&lt;/code&gt; implements &lt;code class=&quot;language-text&quot;&gt;Parcelable&lt;/code&gt;. This tells the Parcelable Extension that it is applicable to this class and it should participate in code generation. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;@AutoValue abstract class Foo implements Parcelable {
  public abstract String bar();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The AutoValue annotation processor will generate a subclass called &lt;code class=&quot;language-text&quot;&gt;$AutoValue_Foo&lt;/code&gt;, which contains all of the normal AutoValue code. Note that it is designated as &lt;code class=&quot;language-text&quot;&gt;abstract&lt;/code&gt; because the Parcelable Extension still needs to fulfill the &lt;code class=&quot;language-text&quot;&gt;Parcelable&lt;/code&gt; interface.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;abstract class $AutoValue_Foo extends Foo {
  $AutoValue_Foo() {...}
  public String bar() {...}
  @Override public String toString() {...}
  @Override public boolean equals(Object o) {...}
  @Override public int hashcode() {...}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The ParcelableExtension will then generate &lt;code class=&quot;language-text&quot;&gt;AutoValue_Foo&lt;/code&gt; that extends &lt;code class=&quot;language-text&quot;&gt;$AutoValue_Foo&lt;/code&gt;. This lets the Parcelable Extension implement the Parcelable interface properly.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;final class AutoValue_Foo extends $AutoValue_Foo {
  @Override public int describeContents() {...}
  @Override public void writeToParcel(Parcel out, int flags) {...}
  public static final Parcelable.Creator&amp;lt;AutoValue_Foo&amp;gt; CREATOR = ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So the full class hierarchy looks like:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;    Foo
     ^
$AutoValue_Foo
     ^
 AutoValue_Foo&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Also note that the final generated class is &lt;em&gt;always&lt;/em&gt; called &lt;code class=&quot;language-text&quot;&gt;AutoValue_Foo&lt;/code&gt;, which means that nothing in the consuming code needs to change!&lt;/p&gt;
&lt;h3&gt;TL;DR&lt;/h3&gt;
&lt;p&gt;AutoValue 1.3 has extensions, they are a powerful way to reduce the boilerplate code associated with value types. Use them!&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;See&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google/auto/issues/202&quot;&gt;Extensibility API Issue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google/auto/pull/237&quot;&gt;Extensibility API Pull Request&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rharter/auto-value-moshi&quot;&gt;AutoValue Moshi Extension&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rharter/auto-value-parcel&quot;&gt;AutoValue Parcelable Extension&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/google/auto/blob/master/value/src/main/java/com/google/auto/value/extension/AutoValueExtension.java&quot;&gt;Source code: AutoValueExtension.java&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item></channel></rss>